

### 🧠 Tableau Synthèse Ultime – Machines de Turing, Classes de Langages, Problèmes, Variantes, Clôtures **(ENRICHIE)**

| **Catégorie**               | **Concept**                          | **Définition / Propriété**                                                                                      | **Exemple / Info Clé**                                                            |
| --------------------------- | ------------------------------------ | --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| 🔧 Machines de Turing       | Machine de Turing                    | Modèle formel pour la notion d’algorithme. Utilise une bande infinie, une tête, un alphabet et des états.       | Simule tout programme : lire/écrire/bouger/changer état                           |
|                             | Composants                           | M = (V, B, Q, q0, F, T) avec V = alphabet d’entrée, B = bande, Q = états, q0 = état init, F = finaux, T = trans | T(q,a) = (b, dir, q′) → lire `a`, écrire `b`, déplacer tête (←/→), aller à q′     |
|                             | Configuration                        | Instantané de l’exécution : ce qui est écrit, où est la tête, et l’état actuel                                  | Représenté par un triplet (w1, q, w2) où la tête est sur le 1er symbole de w2     |
|                             | Exécution                            | Application successive des règles de transition à une configuration donnée                                      | S’arrête si aucune règle applicable ou si atteint un état final                   |
|                             | MT déterministe                      | Une seule règle par (état, symbole) : pas de choix possible                                                     | Exécution unique → + simple à analyser                                            |
|                             | MT non déterministe                  | Plusieurs transitions possibles → l’exécution explore un arbre                                                  | Peut simuler via MT déterministe avec exploration exhaustive (mais + lent)        |
| 🧪 Langages & calculabilité | Langage reconnu                      | Un mot est reconnu si la MT atteint un état final pour ce mot                                                   | Ne garantit pas arrêt pour les mots non reconnus                                  |
|                             | Langage récursif (décidable)         | MT s’arrête **toujours**, accepte ssi mot ∈ L                                                                   | On peut répondre **oui ou non** en temps fini                                     |
|                             | Langage réc. énumérable (r.é.)       | MT s’arrête **seulement** si mot ∈ L (accepte), sinon elle peut tourner à l’infini                              | ⛔ Rejeter = pas garanti → semi-décidabilité                                       |
|                             | Langage co-réc. énumérable (co-r.é.) | Complément est r.é. = on reconnaît **les mots non dans L**                                                      | Pareil, pas garanti de répondre oui, mais on peut dire non en s’arrêtant          |
|                             | Fonction Turing-calculable           | Si MT s’arrête sur **chaque entrée** x, elle calcule f(x)                                                       | Ex : f(x) = x+1 ou f(x) = somme de chiffres                                       |
|                             | Thèse de Church-Turing               | Toute fonction "effectivement calculable" peut l’être par une MT                                                | Equivalence MT ↔ λ-calcul ↔ fonctions récursives                                  |
|                             | MT Universelle                       | MT U qui prend une MT M et une entrée w et simule M sur w                                                       | Comme un interpréteur Python qui lit un programme Python                          |
| 💥 Problèmes classiques     | Problème de l’arrêt                  | Est-ce que M s’arrête sur w ?                                                                                   | Indécidable ❌, mais **semi-décidable** ✅ : on peut détecter si **elle s’arrête**  |
|                             | Problème de la vacuité               | Est-ce que L(M) = ∅ ?                                                                                           | ❌ Indécidable, ✅ co-semi-décidable : on peut détecter les cas **non vides**       |
|                             | Non-vacuité                          | L(M) ≠ ∅ ?                                                                                                      | ✅ Semi-décidable : il suffit de trouver **un mot accepté**                        |
|                             | Égalité de langages r.é.             | L(M1) = L(M2) ?                                                                                                 | 🔥 Ni semi-décidable ni co-semi-décidable                                         |
|                             | Égalité de fonctions Turing-calc.    | ∀x, f(x) = g(x) ?                                                                                               | Même complexité que l’arrêt → indécidable                                         |
|                             | Arrêt uniforme                       | Est-ce que M s’arrête sur **toutes** les entrées ?                                                              | Ultra-chaud : même pas r.é. ni co-r.é.                                            |
| 🧠 Définitions logiques     | Décidable                            | MT **accepte ou rejette** chaque mot en **temps fini**                                                          | = Langage récursif                                                                |
|                             | Semi-décidable                       | MT s’arrête **seulement si** le mot est dans le langage                                                         | = Langage r.é.                                                                    |
|                             | Co-semi-décidable                    | MT s’arrête **seulement si** le mot n’est pas dans le langage                                                   | = Complément d’un r.é.                                                            |
|                             | L récursif ⇔ L et ¬L r.é.            | Si L et son complément sont tous deux semi-décidables → L est décidable                                         | Utilisé pour prouver la décidabilité                                              |
| 🔧 Réductions               | Réduction (décidabilité)             | Si L1 ↝ L2 et L2 est décidable, alors L1 aussi                                                                  | ⚠️ Faut une réductibilité efficace (ex : fonction calculable)                     |
|                             | Réduction (indécidabilité)           | Si L1 est indécidable et L1 ↝ L2, alors L2 l’est aussi                                                          | Technique pour propager l’indécidabilité                                          |
| 🧱 Théorème de Rice         | Propriétés non triviales             | Toute propriété non triviale d’un langage reconnu par une MT est indécidable                                    | Non trivial = vraie pour au moins un langage et fausse pour au moins un autre     |
| 🧩 Classe NP                | NP                                   | Problèmes dont **une solution** peut être vérifiée en temps polynomial par une machine déterministe             | ⛔ Trouver solution = dur, ✅ Vérifier solution = facile                            |
|                             | NP-complet                           | Problèmes les + "compliqués" de NP : tout problème NP peut s’y réduire                                          | Si t’en résous un en poly → tu résous tous les autres                             |
|                             | Réduction polynomiale                | Transformer un problème en un autre en **temps polynomial**                                                     | SAT → 3SAT → CLIQUE → plein d'autres                                              |
|                             | Problèmes NP                         | Tous sont **décidables**, même si résolution peut être exponentielle                                            | Classe ⊆ P^?^ (si P = NP ? 😵‍💫)                                                 |
| 🛠 Variantes équivalentes   | Alphabet binaire uniquement          | Toute MT avec alphabet ≠ binaire peut être **encodée** sur binaire                                              | Simule par codage (ex: a → 00, b → 01, etc.)                                      |
|                             | Sans transitions sur place           | Peut être simulé en écrivant puis revenant                                                                      | Nécessite des états intermédiaires                                                |
|                             | MT à plusieurs bandes                | k bandes peuvent être encodées sur une seule bande avec séparateurs                                             | Rend la MT + rapide (dans les faits), mais pas + puissante                        |
|                             | MT à plusieurs têtes                 | Simulable avec une seule bande + codage de positions                                                            | Beaucoup + galère mais même puissance                                             |
|                             | MT à deux piles                      | Équivaut à MT classique                                                                                         | Peut simuler pile via la bande                                                    |
|                             | Problème arrêt 2 piles               | Toujours indécidable                                                                                            | Même complexité que MT classique                                                  |
| 📚 Clôtures                 | Récursifs (décidables)               | Fermés sous ∪, ∩, ¬, concaténation, étoile                                                                      | Super stables : tu peux construire des langages compliqués et garder décidabilité |
|                             | Récursivement énumérables            | Fermés sous ∪, ∩ mais **pas** ¬                                                                                 | Ex : L\_u = r.é., mais ¬L\_u = pas r.é. → pas fermé sous complément               |
|                             | Clôture et décidabilité              | Si L et ¬L sont tous deux semi-décidables ⇒ L est récursif                                                      | À mémoriser comme théorème de characterization                                    |

---

---

### 📚 **Clôtures – Définitions & Propriétés enrichies**

| **Concept**                                   | **Définition / Propriété**                                                                                                                                                                 | **Exemple / Info Clé**                                                                            |                   |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------- | ----------------- |
| **Opération**                                 | Une opération transforme des langages en un autre : ∪, ∩, ¬, concaténation, étoile, homomorphisme, etc.                                                                                    | Exemple : L₁ ∪ L₂ = {w                                                                            | w ∈ L₁ ou w ∈ L₂} |
| **Clôture**                                   | Une **classe de langages** est dite **fermée** (ou **clôturée**) par une opération si appliquer cette opération à des langages de la classe donne un langage qui **reste dans la classe**. | Ex : Si L₁ et L₂ sont récursifs, alors L₁ ∩ L₂ est aussi récursif → donc récursif **fermé** par ∩ |                   |
| **Fermeture (mathématiquement)**              | Soit une classe **C**, et une opération **◦**, on dit que C est **fermée** par ◦ si ∀ L₁, L₂ ∈ C ⇒ L₁ ◦ L₂ ∈ C                                                                             | Formule clean : C est fermée par ◦ ⟺ ∀ L₁,L₂ ∈ C, L₁ ◦ L₂ ∈ C                                     |                   |
| **Utilité des clôtures**                      | Connaître les opérations de clôture permet de construire de nouveaux langages **sans sortir de la classe**, ou de **prouver qu’un langage n’y est pas** s’il n’est pas stable.             | Strat de preuve : si L₁ ∪ L₂ ∉ C alors l’un au moins des deux n’est pas dans C                    |                   |
| **Langages récursifs (≡ décidables)**         | **Fermés sous :** ∪, ∩, ¬, concaténation, étoile, etc.                                                                                                                                     | Super classe stable → combine tout, reste toujours décidable                                      |                   |
| **Langages récursivement énumérables (r.é.)** | **Fermés sous :** ∪, ∩ mais **pas** sous ¬ (complément)                                                                                                                                    | ⚠️ Le complément d’un r.é. n’est **pas forcément** r.é.                                           |                   |
| **Langages co-récursivement énumérables**     | Fermés sous ∪, mais pas forcément sous ∩ ni ¬                                                                                                                                              | Pareil, la fermeture est partielle                                                                |                   |
| **Clôture et intersection**                   | r.é. et co-r.é. sont **fermés sous intersection avec un récursif**                                                                                                                         | Si L ∈ r.é. et R ∈ récursif ⇒ L ∩ R ∈ r.é.                                                        |                   |
| **Non-fermeture utile en preuve**             | Si tu sais qu’une classe n’est **pas fermée** sous une opération, tu peux t’en servir pour montrer qu’un langage **n’appartient pas** à cette classe                                       | Ex : ¬L\_u n’est pas r.é. → donc r.é. n’est pas fermé sous complément                             |                   |
| **Test de double semi-décidabilité**          | Si L ∈ r.é. et ¬L ∈ r.é. ⇒ L est récursif                                                                                                                                                  | Méga classique en exam pour détecter si un langage est dans la classe des décidables              |                   |

---


