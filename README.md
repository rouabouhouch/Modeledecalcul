

### ğŸ§  Tableau SynthÃ¨se Ultime â€“ Machines de Turing, Classes de Langages, ProblÃ¨mes, Variantes, ClÃ´tures **(ENRICHIE)**

| **CatÃ©gorie**               | **Concept**                          | **DÃ©finition / PropriÃ©tÃ©**                                                                                      | **Exemple / Info ClÃ©**                                                            |
| --------------------------- | ------------------------------------ | --------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------- |
| ğŸ”§ Machines de Turing       | Machine de Turing                    | ModÃ¨le formel pour la notion dâ€™algorithme. Utilise une bande infinie, une tÃªte, un alphabet et des Ã©tats.       | Simule tout programme : lire/Ã©crire/bouger/changer Ã©tat                           |
|                             | Composants                           | M = (V, B, Q, q0, F, T) avec V = alphabet dâ€™entrÃ©e, B = bande, Q = Ã©tats, q0 = Ã©tat init, F = finaux, T = trans | T(q,a) = (b, dir, qâ€²) â†’ lire `a`, Ã©crire `b`, dÃ©placer tÃªte (â†/â†’), aller Ã  qâ€²     |
|                             | Configuration                        | InstantanÃ© de lâ€™exÃ©cution : ce qui est Ã©crit, oÃ¹ est la tÃªte, et lâ€™Ã©tat actuel                                  | ReprÃ©sentÃ© par un triplet (w1, q, w2) oÃ¹ la tÃªte est sur le 1er symbole de w2     |
|                             | ExÃ©cution                            | Application successive des rÃ¨gles de transition Ã  une configuration donnÃ©e                                      | Sâ€™arrÃªte si aucune rÃ¨gle applicable ou si atteint un Ã©tat final                   |
|                             | MT dÃ©terministe                      | Une seule rÃ¨gle par (Ã©tat, symbole) : pas de choix possible                                                     | ExÃ©cution unique â†’ + simple Ã  analyser                                            |
|                             | MT non dÃ©terministe                  | Plusieurs transitions possibles â†’ lâ€™exÃ©cution explore un arbre                                                  | Peut simuler via MT dÃ©terministe avec exploration exhaustive (mais + lent)        |
| ğŸ§ª Langages & calculabilitÃ© | Langage reconnu                      | Un mot est reconnu si la MT atteint un Ã©tat final pour ce mot                                                   | Ne garantit pas arrÃªt pour les mots non reconnus                                  |
|                             | Langage rÃ©cursif (dÃ©cidable)         | MT sâ€™arrÃªte **toujours**, accepte ssi mot âˆˆ L                                                                   | On peut rÃ©pondre **oui ou non** en temps fini                                     |
|                             | Langage rÃ©c. Ã©numÃ©rable (r.Ã©.)       | MT sâ€™arrÃªte **seulement** si mot âˆˆ L (accepte), sinon elle peut tourner Ã  lâ€™infini                              | â›” Rejeter = pas garanti â†’ semi-dÃ©cidabilitÃ©                                       |
|                             | Langage co-rÃ©c. Ã©numÃ©rable (co-r.Ã©.) | ComplÃ©ment est r.Ã©. = on reconnaÃ®t **les mots non dans L**                                                      | Pareil, pas garanti de rÃ©pondre oui, mais on peut dire non en sâ€™arrÃªtant          |
|                             | Fonction Turing-calculable           | Si MT sâ€™arrÃªte sur **chaque entrÃ©e** x, elle calcule f(x)                                                       | Ex : f(x) = x+1 ou f(x) = somme de chiffres                                       |
|                             | ThÃ¨se de Church-Turing               | Toute fonction "effectivement calculable" peut lâ€™Ãªtre par une MT                                                | Equivalence MT â†” Î»-calcul â†” fonctions rÃ©cursives                                  |
|                             | MT Universelle                       | MT U qui prend une MT M et une entrÃ©e w et simule M sur w                                                       | Comme un interprÃ©teur Python qui lit un programme Python                          |
| ğŸ’¥ ProblÃ¨mes classiques     | ProblÃ¨me de lâ€™arrÃªt                  | Est-ce que M sâ€™arrÃªte sur w ?                                                                                   | IndÃ©cidable âŒ, mais **semi-dÃ©cidable** âœ… : on peut dÃ©tecter si **elle sâ€™arrÃªte**  |
|                             | ProblÃ¨me de la vacuitÃ©               | Est-ce que L(M) = âˆ… ?                                                                                           | âŒ IndÃ©cidable, âœ… co-semi-dÃ©cidable : on peut dÃ©tecter les cas **non vides**       |
|                             | Non-vacuitÃ©                          | L(M) â‰  âˆ… ?                                                                                                      | âœ… Semi-dÃ©cidable : il suffit de trouver **un mot acceptÃ©**                        |
|                             | Ã‰galitÃ© de langages r.Ã©.             | L(M1) = L(M2) ?                                                                                                 | ğŸ”¥ Ni semi-dÃ©cidable ni co-semi-dÃ©cidable                                         |
|                             | Ã‰galitÃ© de fonctions Turing-calc.    | âˆ€x, f(x) = g(x) ?                                                                                               | MÃªme complexitÃ© que lâ€™arrÃªt â†’ indÃ©cidable                                         |
|                             | ArrÃªt uniforme                       | Est-ce que M sâ€™arrÃªte sur **toutes** les entrÃ©es ?                                                              | Ultra-chaud : mÃªme pas r.Ã©. ni co-r.Ã©.                                            |
| ğŸ§  DÃ©finitions logiques     | DÃ©cidable                            | MT **accepte ou rejette** chaque mot en **temps fini**                                                          | = Langage rÃ©cursif                                                                |
|                             | Semi-dÃ©cidable                       | MT sâ€™arrÃªte **seulement si** le mot est dans le langage                                                         | = Langage r.Ã©.                                                                    |
|                             | Co-semi-dÃ©cidable                    | MT sâ€™arrÃªte **seulement si** le mot nâ€™est pas dans le langage                                                   | = ComplÃ©ment dâ€™un r.Ã©.                                                            |
|                             | L rÃ©cursif â‡” L et Â¬L r.Ã©.            | Si L et son complÃ©ment sont tous deux semi-dÃ©cidables â†’ L est dÃ©cidable                                         | UtilisÃ© pour prouver la dÃ©cidabilitÃ©                                              |
| ğŸ”§ RÃ©ductions               | RÃ©duction (dÃ©cidabilitÃ©)             | Si L1 â† L2 et L2 est dÃ©cidable, alors L1 aussi                                                                  | âš ï¸ Faut une rÃ©ductibilitÃ© efficace (ex : fonction calculable)                     |
|                             | RÃ©duction (indÃ©cidabilitÃ©)           | Si L1 est indÃ©cidable et L1 â† L2, alors L2 lâ€™est aussi                                                          | Technique pour propager lâ€™indÃ©cidabilitÃ©                                          |
| ğŸ§± ThÃ©orÃ¨me de Rice         | PropriÃ©tÃ©s non triviales             | Toute propriÃ©tÃ© non triviale dâ€™un langage reconnu par une MT est indÃ©cidable                                    | Non trivial = vraie pour au moins un langage et fausse pour au moins un autre     |
| ğŸ§© Classe NP                | NP                                   | ProblÃ¨mes dont **une solution** peut Ãªtre vÃ©rifiÃ©e en temps polynomial par une machine dÃ©terministe             | â›” Trouver solution = dur, âœ… VÃ©rifier solution = facile                            |
|                             | NP-complet                           | ProblÃ¨mes les + "compliquÃ©s" de NP : tout problÃ¨me NP peut sâ€™y rÃ©duire                                          | Si tâ€™en rÃ©sous un en poly â†’ tu rÃ©sous tous les autres                             |
|                             | RÃ©duction polynomiale                | Transformer un problÃ¨me en un autre en **temps polynomial**                                                     | SAT â†’ 3SAT â†’ CLIQUE â†’ plein d'autres                                              |
|                             | ProblÃ¨mes NP                         | Tous sont **dÃ©cidables**, mÃªme si rÃ©solution peut Ãªtre exponentielle                                            | Classe âŠ† P^?^ (si P = NP ? ğŸ˜µâ€ğŸ’«)                                                 |
| ğŸ›  Variantes Ã©quivalentes   | Alphabet binaire uniquement          | Toute MT avec alphabet â‰  binaire peut Ãªtre **encodÃ©e** sur binaire                                              | Simule par codage (ex: a â†’ 00, b â†’ 01, etc.)                                      |
|                             | Sans transitions sur place           | Peut Ãªtre simulÃ© en Ã©crivant puis revenant                                                                      | NÃ©cessite des Ã©tats intermÃ©diaires                                                |
|                             | MT Ã  plusieurs bandes                | k bandes peuvent Ãªtre encodÃ©es sur une seule bande avec sÃ©parateurs                                             | Rend la MT + rapide (dans les faits), mais pas + puissante                        |
|                             | MT Ã  plusieurs tÃªtes                 | Simulable avec une seule bande + codage de positions                                                            | Beaucoup + galÃ¨re mais mÃªme puissance                                             |
|                             | MT Ã  deux piles                      | Ã‰quivaut Ã  MT classique                                                                                         | Peut simuler pile via la bande                                                    |
|                             | ProblÃ¨me arrÃªt 2 piles               | Toujours indÃ©cidable                                                                                            | MÃªme complexitÃ© que MT classique                                                  |
| ğŸ“š ClÃ´tures                 | RÃ©cursifs (dÃ©cidables)               | FermÃ©s sous âˆª, âˆ©, Â¬, concatÃ©nation, Ã©toile                                                                      | Super stables : tu peux construire des langages compliquÃ©s et garder dÃ©cidabilitÃ© |
|                             | RÃ©cursivement Ã©numÃ©rables            | FermÃ©s sous âˆª, âˆ© mais **pas** Â¬                                                                                 | Ex : L\_u = r.Ã©., mais Â¬L\_u = pas r.Ã©. â†’ pas fermÃ© sous complÃ©ment               |
|                             | ClÃ´ture et dÃ©cidabilitÃ©              | Si L et Â¬L sont tous deux semi-dÃ©cidables â‡’ L est rÃ©cursif                                                      | Ã€ mÃ©moriser comme thÃ©orÃ¨me de characterization                                    |

---

---

### ğŸ“š **ClÃ´tures â€“ DÃ©finitions & PropriÃ©tÃ©s enrichies**

| **Concept**                                   | **DÃ©finition / PropriÃ©tÃ©**                                                                                                                                                                 | **Exemple / Info ClÃ©**                                                                            |                   |
| --------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------- | ----------------- |
| **OpÃ©ration**                                 | Une opÃ©ration transforme des langages en un autre : âˆª, âˆ©, Â¬, concatÃ©nation, Ã©toile, homomorphisme, etc.                                                                                    | Exemple : Lâ‚ âˆª Lâ‚‚ = {w                                                                            | w âˆˆ Lâ‚ ou w âˆˆ Lâ‚‚} |
| **ClÃ´ture**                                   | Une **classe de langages** est dite **fermÃ©e** (ou **clÃ´turÃ©e**) par une opÃ©ration si appliquer cette opÃ©ration Ã  des langages de la classe donne un langage qui **reste dans la classe**. | Ex : Si Lâ‚ et Lâ‚‚ sont rÃ©cursifs, alors Lâ‚ âˆ© Lâ‚‚ est aussi rÃ©cursif â†’ donc rÃ©cursif **fermÃ©** par âˆ© |                   |
| **Fermeture (mathÃ©matiquement)**              | Soit une classe **C**, et une opÃ©ration **â—¦**, on dit que C est **fermÃ©e** par â—¦ si âˆ€ Lâ‚, Lâ‚‚ âˆˆ C â‡’ Lâ‚ â—¦ Lâ‚‚ âˆˆ C                                                                             | Formule clean : C est fermÃ©e par â—¦ âŸº âˆ€ Lâ‚,Lâ‚‚ âˆˆ C, Lâ‚ â—¦ Lâ‚‚ âˆˆ C                                     |                   |
| **UtilitÃ© des clÃ´tures**                      | ConnaÃ®tre les opÃ©rations de clÃ´ture permet de construire de nouveaux langages **sans sortir de la classe**, ou de **prouver quâ€™un langage nâ€™y est pas** sâ€™il nâ€™est pas stable.             | Strat de preuve : si Lâ‚ âˆª Lâ‚‚ âˆ‰ C alors lâ€™un au moins des deux nâ€™est pas dans C                    |                   |
| **Langages rÃ©cursifs (â‰¡ dÃ©cidables)**         | **FermÃ©s sous :** âˆª, âˆ©, Â¬, concatÃ©nation, Ã©toile, etc.                                                                                                                                     | Super classe stable â†’ combine tout, reste toujours dÃ©cidable                                      |                   |
| **Langages rÃ©cursivement Ã©numÃ©rables (r.Ã©.)** | **FermÃ©s sous :** âˆª, âˆ© mais **pas** sous Â¬ (complÃ©ment)                                                                                                                                    | âš ï¸ Le complÃ©ment dâ€™un r.Ã©. nâ€™est **pas forcÃ©ment** r.Ã©.                                           |                   |
| **Langages co-rÃ©cursivement Ã©numÃ©rables**     | FermÃ©s sous âˆª, mais pas forcÃ©ment sous âˆ© ni Â¬                                                                                                                                              | Pareil, la fermeture est partielle                                                                |                   |
| **ClÃ´ture et intersection**                   | r.Ã©. et co-r.Ã©. sont **fermÃ©s sous intersection avec un rÃ©cursif**                                                                                                                         | Si L âˆˆ r.Ã©. et R âˆˆ rÃ©cursif â‡’ L âˆ© R âˆˆ r.Ã©.                                                        |                   |
| **Non-fermeture utile en preuve**             | Si tu sais quâ€™une classe nâ€™est **pas fermÃ©e** sous une opÃ©ration, tu peux tâ€™en servir pour montrer quâ€™un langage **nâ€™appartient pas** Ã  cette classe                                       | Ex : Â¬L\_u nâ€™est pas r.Ã©. â†’ donc r.Ã©. nâ€™est pas fermÃ© sous complÃ©ment                             |                   |
| **Test de double semi-dÃ©cidabilitÃ©**          | Si L âˆˆ r.Ã©. et Â¬L âˆˆ r.Ã©. â‡’ L est rÃ©cursif                                                                                                                                                  | MÃ©ga classique en exam pour dÃ©tecter si un langage est dans la classe des dÃ©cidables              |                   |

---


